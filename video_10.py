"""
Цей приклад практичний, але є ньюанс
У яких випадках потрібні дужки біля класу - дізнаєтеся з наступних уроків
Будь який клас стане контекстним менеджером, якщо в ньому реалізовані методи enter та exit

Якщо будемо обробляти помилку то в init мабуть слід буде передати інші параметри exc_type, exc_val, exc_tb) ?

enter бере у нашому обєкті file - просто відкриває нам файл

далі return self.file - повертає відкритий файл у контекстний менеджер - бо нам потрібно буде далі
працювати із цим файлом

в методі exit - ми закриваємо цей наш файл - у будь якому випадку нам потрібно закрити файл

В конструкції
with OpenFile("example.txt", "a") as f:
    f.write("\nSome other line")

ми можемо здійнювати ті дії які потрібно із нашим відкритим файлом f


"""



class OpenFile:

    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        print("Відкрито успішно")
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()

with OpenFile("example.txt", "a") as f:
    f.write("\nSome other line")


print(f.closed) #поверне True якщо файл закрився

"""
Створимо такий самий контекстний менеджер за допомогою декоратора
from contextlib import contextmanager - імпортуємо декоратор contextmanager з бібліотеки contextlib
створюємо ф-ю open_file
file = open(filename, mode) - в змінну file записуємо відкритий файл
yield file - повертаємо наш файл єлдом
все що ми повертаємо потрапляє в  as f:
тому код yield file - є обовязковим, тому що у блоці 

with open_file("example.txt", "a") as f:
    f.write("\nSome data")
    
ми маємо мати можливість працювати із нашим відкритим файлом

коли попрацювали, то робимо файл клоус
"""

from contextlib import contextmanager

@contextmanager
def open_file(filename, mode):
    file = open(filename, mode)
    yield file
    file.close()

with open_file("example.txt", "a") as f:
    f.write("\nSome data")

"""
Відпрацювало, записало. Але що буде у випадку якщо буде якась помилка? 
Треба тоді в код дописати try і finnaly
можемо використовувати блок try, finnaly без except - якщо ми не хочемо щоб виводилась помилка, але після коду
маємо зробити обовязкові дії
"""
from contextlib import contextmanager

@contextmanager
def open_file(filename, mode):
    try:
        file = open(filename, mode)
        yield file
    finally:
        file.close()

with open_file("example.txt", "a") as f:
    f.write("\nSome data")

"""
Працює, але з класом зручніше.
"""

"""
Повернемося до коду створення к м за допомогою класу
Він не має практичної цінності, оскільки у пайтон є вбудований метод
open який робить усе те ж саме
with open("example.txt", "a") as f:
    f.write("\nSome other line")
    
Але ми спеціально самі створили його самостійно щоб зрозуміти що у нас плюс мінус у методі open - як він працює
всередині

по принципу того як ми створили контекст менеджер для роботи з файлами, то ми можемо створювати контекстні 
менеджери для будь якої задачі

Головне розібрати основні концепти:
слід створити 2 магічні методи 
з методу enter нам потрібно повернути обєкт нашого контекстного менеджера
те що попаде у змінну f
те з чим ми будемо працювати у блоці with
блок exit почне виконуватися, якщо закінчиться код у блоці with, або якщо у цьому коді виникне помилка,
але цей блок обовязково буде виконуватися

Прорезюмуємо увесь урок по контестних менеджерах:
1. К м - створені для того щоб наш код був безпечним
2 щоб код працював правильно, не втрачалась операційна память і т.п. проблеми
3 якщо потрібно зробити якісь обовязкові дії - то робимо їх за допомогою к м
наприклад tearDown - це метод, який використовується для прибирання після виконання тесту чи набору тестів. 
Він дозволяє звільнити ресурси, закрити з'єднання до бази даних, закрити файли тощо після завершення тестової
функції чи класу.
К м забезпечує те що при будь яких обставинах метод exit виконається
4 Для створення км можемо використовувати декоратор contextmanager , 
або можемо створити клас з двома обовязковими методами enter та exit - вхід та вихід
в enter ми щось робимо і повертаємо наш обєкт return self.f
exit виконається якщо код відпрацює успішно, або код видасть помилку - але exit виконається
км - це спрощений, більш зручний варіант try, except, finally

"""