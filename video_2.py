"""
Буду намагатися максимально просто пояснити про замикання

"""

def talk():

    def say_hi():
        return f"Hello"

    return say_hi()

my_func = talk()
print(talk())
print(my_func)

"""
нехай десь буде створена змінна name = "Vlad"
тепер коли створюється ф-я talk  то також створюється змінна name, яке ми будемо використовувати у 
внутрішній ф-ї
"""
def talk():

    name = "Vlad"

    def say_hi():
        return f"Hello, {name}"

    return say_hi()

my_func = talk()
print(talk())
print(my_func)

"""
давайте подумаємо що відбулося з точки зору інтерпретатора пайтон
коли код виконується, то враховуючи області видимості, усі змінні які не використовуються будутьвидалені
змінна name видалятися не буде, оскільми ми замкнули - запамятали, зберегли значення змінної name 
усередині ф-ї say_hi()
Виходить така штука:
внутрішня ф-я say_hi() замкнула(запамятала це значення всередині себе) у собі змінну name
кожого разу say_hi() буде повертати Hello Vlad, бо ми запамятали значення із зовнішньої ф-ї
не дуже зрозуміло як це використати на практиці
створимо інший приклад
"""
def outer(x):

    def inner(y):
        return x + y

    return inner

add_5 = outer(5)
print(add_5)
print(add_5(3))
print(add_5(10))

add_10 = outer(10) # цей рядок означає що ми замикаємо значення 10
print(add_10(3))
print(add_10(10))


"""
тепер це значення  збережеться в outer(x)
внутрішня ф-я inner коли буде виконуватися замикає у собі те що x = 5
і виходить так що внутрішня ф-я inner перетворилася на таку, що просто увесь час додає 5
add_5 створили за допомогою нашої фабрики
і запамятали, замкнули значення змінної x із зовнішньої області видимості у внутрішній ф-ї
додамо add_10
перша ф-я add_5 працює по своєму, а add_10 працює по своєму - одна додає 5, а інша додає 10
ми вже зробили таку цікаву автоматизацію, ми можемо якось динамічно з цим працювати
розглянемо ще один цікавий прикад
зробимо лічильник того скільки викликалася ф-я
"""

def counter():
    counter = 0

    def increment():
        nonlocal counter
        counter += 1
        return f"Counter: {counter}"

    return increment()

v_1 = counter()
print(v_1)

v_2 = counter()
print(v_2)

"""
буде помилка
слід дописати nonlocal counter
nonlocal - це означає що ми не просто хочемо використовувати змінну з іншої області видимості
Справа у тому що якщо у внутрішній ф-ї ми просто виводили б counter -  то ніякої помилки не було
але ми хочемо у внутрішній ф-ї змінити змінну із зовнішньої області видимості - для цього слід
дописати nonlocal
nonlocal counter - означає - використовуй Counter Який знаходиться у зовнішній області видимості

"""