"""
Чому все інше було важливим вивчати перед цим
Створимо простий декоратор. Декоратор - це ф-я.
Декоратор можемо назвати як нам завгодно
Що потрібно зробити обовязково
Все є обєкт
Ми можемо передавати ф-ї всередині інших ф-й
Параметром для декоратора повинна бути саме ф-я
Передаємо саме обєкт ф-ї, не виклик ф-ї, а саме обєкт ф-ї, яку ми будемо декорувати
Для джуніор девелоперів означення декоратора:
Декоратор - це паттерн проєктування, але який реалізований у пайтон за допомогою стандартних бібліотек
але
для чого потрібен декоратор?
Він - розширює функціонал будь якої ф-ї, не змінюючи саму ф-ю
Частіше за все функціонал додається до та після виклику ф-ї
Ми взагалі не змінюємо ф-ю, яку ми декоруємо
А додаємо функціонал
На практиці це потрібно для того, що якщо є декілька ф-1 і ми хочемо додати спільні риси до цих ф-й,
але не змінювати самі ці ф-ї.
На практиці в одному декораторі прописуємо увесь функціонал який хочемо додати, а потім декоруємо
усі решта ф-й які потрібно
func - це ф-я яку ми хочемо декорувати
func ми замикаємо в області видимості inner()
щоб викликати декоратор, то нам спочатку слід створити ф-ю say_hi
Тепер ми хочемо задекорувати ф-ю say_hi
Декоратор - це по суті фабрика ф-й
decorator_say_hi = decorator(say_hi) - передаємо саме обєкт ф-ї, а не виклик ф-ї
якщо запишемо у дужки виклик ф-ї - то вона передасть те що ця ф-я повертає
decorated_say_hi - це декорованя ф-я
для того щоб її викликати вказуємо дужки decorated_say_hi()
Декоратор додає функціонал до ф-ї, розширює можливості ф-ї, але не змінює цю ф-ю
Декоратор зручний у дуже багатьох випадках
Декоратор - це дуже популярний паттерн програмування
Будемо розбирати усі концепції декораторів
decorator(func) - замість слова decorator може бути якась інша назва
inner() - замість слова inner може бути якась інша назва

"""

def decorator(func):

    def inner():
        print('start')
        func()
        print('end')

    return  inner

def say_hi():
    print("Hello")

decorated_say_hi = decorator(say_hi)#декоратор повертає обєкт, decorated_say_hi має також бути обєктом
print(decorated_say_hi)
print(100*'*')
decorated_say_hi()
print(100*'*')
say_hi()
print(100*'*')

"""
створимо ф-ю say_bye()

тепер завдання: декорувати say_bye() і say_hi()

не дуже зручно створювати окремий декоратор для кожної ф-ї decorated_say_hi, decorated_say_by

можна зробити так що при виклику say_hi() одразу викликалася декорована ф-я, це якщо ми задумали так щоб так 
викликалось

say_hi = decorator(say_hi) - перевизначили ф-ю, або за назвою ф-ї say_hi прописали результат який видає декоратор 
"""
def decorator(func):

    def inner():
        print('start')
        func()
        print('end')

    return  inner

def say_hi():
    print("Hello")

def say_by():
    print('Bye')


say_hi = decorator(say_hi)
say_hi()

print(100*'*')

say_by = decorator(say_by)
say_by()

""" 
ми задекорували одним декоратором дві ф-ї
пайтон - це про простоту
розробники пайтон створили для нас зручний синтаксис для роботи з декораторами 

можемо використовувати
@decorator

тепер виклик say_hi() - це буде той самий результат, що і прописати 
say_hi = decorator(say_hi)
say_hi()

якщо заберемо @decorator над say_by() - то викличеться оригінальна ф-я, а не декорована - можемо перевірити викликом

@decorator - сленговою мовою називається синтаксичний цукор, через це що так більш читабельно і більш зручніше з цим
працювати - мається на увазі що підсолоджує життя, щоб ми більш красиво писали наш код

Декоратор створюється за допомогою зовнішньої ф-ї, параметром у яку обовязково передається обєкт ф-ї яку хочемо
декорувати. Далі всередині зовнішньої ф-ї створюємо внутрішню ф-ю. У внутрішній ф-ї буде додатковий функціонал та 
оригінальна ф-я, яка таким чином декорується. Декоратор повертає внутрішню ф-ю.
"""
def decorator(func):

    def inner():
        print('start')
        func()
        print('end')

    return  inner

@decorator
def say_hi():
    print("Hello")

@decorator
def say_by():
    print('Bye')

print(100*'-')
say_hi()
print(100*'-')

say_by()
print(100*'-')



















